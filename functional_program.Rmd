---
title: Functional Programming with `R`
author: "Miles D. Williams"
date: "2019 UIUC Political Science Math Camp"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Now that you've gained some familiarity with loops, let's add just another layer of complexity. This won't hurt too badly, I promise...

`R` is a functional programming language. In short, that means that you can create your own functions in `R` that will do basically whatever you tell them to do. (Word to the wise, it will also do whatever stupid thing you tell it to do)

This might seem like an odd feature. Why write a new function? `R` already comes with so many nice built-in functions; adding our own may appear silly.

But, consider for a moment the value of the `for` loop. It allows you to automate an iterative task. It takes what would otherwise require 1,000 lines of code and condenses it to a mere handful. Functional programming allows you to do much the same thing. In fact, you can write functions that perform loops for you, without having to rewrite a loop each time you want to do an iterative task.

Consider the following simple loop:

```{r}

# We first create a 10 x 10 matrix of zeros
x = matrix(0, ncol = 10, nrow = 10)
x # Show matrix

# We then fill each column of this matrix with random variables, but
# with the mean centered at a value equal to the column number,
# e.g., for column 1, the mean of the random variable to be generated will be 1.

# The loop:
for(i in 1:ncol(x)){
  x[,i] = rnorm(n = nrow(x), sd = 1, mean = i)
}
```

Here's the output from the loop:

```{r}
x
```

Now let's say we want to be able to specify what the mean will be in each column, and for that matter the standard deviation:

```{r}
x = matrix(0, ncol = 10, nrow = 10)
means = c(4,9,3,4,0,-1,8,6,2,5)
sds = c(.3,8,9,.5,2,1,6,3,7,2)
for(i in 1:ncol(x)){
  x[,i] = rnorm(n = nrow(x), sd = sds[i], means[i])
}
x
```

Now, don't get me wrong, I love `R`, but writing all that out was tedious. I don't really want to rewrite all that every time I want to generate a matrix of random variables...functional programming to the rescue!

`R` lets you write over a particular routine and save that routine as a function. This is done straightforwardly with the `function()` command. For example, consider the following coin tossing function:

```{r}
# My coin function:
coin = function(tosses = 1){
  out = sample(c("heads","tails"),replace = T, size = tosses)
  return(out)
}

# Let's check out the output
coin()

# Let's take the mean number of heads after 10 tosses
mean(coin(10)=="heads")
```

The basic outline of writing a function is simple:
  
  1. specify the name of the function you want to create:

  - `coin =` (this can also be done with the longer `<-`)
  
  2. Use `function()` and place inside the object you want the function to work on or commands you want to be able specify (you can also specify default options, e.g. `tosses = 1`:
  
  - `coin = function(tosses = 1)` 
  
  3. Then, in brackets, we specify the routine we want the function to automate:
  
  - `coin = function(tosses = 1) { ... }`
  
  
Pretty simple right? Can we apply this to the loop example above? Let's give it a go.

```{r}
random_mat = function(
  n, # number of rows
  k  # number of columns
) {
  
  # Make empty n x k matrix
  x = matrix(0, ncol = k, nrow = n)
  
  # Have routine pick a random mean per column
  means = rnorm(n = k)
  
  # Have routine pick a random sd per column
  sds = exp(rnorm(n = k))
  
  # Fill the matrix
  for(i in 1:k){
    x[,i] = rnorm(n = n, sd = sds[i], means[i])
  }
  
  # Have the function return the filled matrix
  return(x)
}
```

Does it work? Set `n = 10` and `k = 3`:

```{r}
random_mat(n = 10, k = 3)
```

It works perfectly. 

Now, how about a dice rolling function?

```{r}
dice = function(sides = 6, rolls = 1){
  out = sum(sample(1:sides, replace = T, size = rolls))
  return(out)
}

# Test it
dice(rolls = 10)
```

```{r}
outcomes = 0
for(i in 1:1000){
  outcomes[i] = dice(rolls = 10)
}
plot(density(outcomes))
```


# Practice


Now it's your turn. 

  1. Can you finish the function below for a routine that plots the mean number of heads per `1:n` number of tosses? As n gets bigger, the results should converge toward 0.5, but they don't. What do you need to fix in the below function to make it work correctly? Make the change and check the results (hint: the `i`s have it).
  
```{r, eval = F}
plot_n_tosses = function(n = 1000){
  means = 0
  for(i in 1:n){
    means[i] = mean(coin(n)=="heads")
  }
  plot(1:n,means,type="l",
       xlab="n tosses",ylab="proportion heads")
  abline(h=.5)
}
plot_n_tosses()
```

  2. Applying the framework for `plot_n_tosses` in the previous problem, write a function called `plot_n_rolls` that plots the mean value you get going from 1 to n rolls of a die per die (hint: outcome = $\bar{x}/\text{rolls}$.
  
```{r}
plot_n_rolls = function(n = 1000){
  means = 0
  for(i in 1:n){
    means[i] = mean(dice(rolls = i))/i
  }
  plot(1:n,means,type="l",
       xlab="n rolls",ylab="mean value")
  abline(h=3.5)
}
plot_n_rolls()
```


  3. You can use the `rbinom` function to generate random 0s and 1s from a binomial distribution. Below is a new coin function that returns heads or tails, but it differs from the previous coin function in that you can specify the probability that you get heads. With this new coin function, write a histogram function that plots the frequency you get a proportion of heads per 100 tosses.
  
```{r}
coin2 = function(tosses = 1, bias = 0.5){
  out = rbinom(n = tosses, size = 1, prob = bias)
  out[out==1] = "heads"
  out[out==0] = "tails"
  return(out)
}
coin2(tosses = 50)
```

```{r}
coin_hist = function(times = 100, tosses = 100, bias = 0.5){
  result = 0
  for(i in 1:times){
    result[i] = mean(coin2(tosses = tosses, bias = bias)=="heads")
  }
  hist(result,main = paste0("tosses = ",tosses,"; iterations = ",times))
}
coin_hist(bias = .05, times = 1000)
```

  
  